### 이도영 202230123

## 4월 10일 (6주차)
# 클래스와 사물  
**세상 모든 것이 되다**

---

## 실세계 사물의 특징

- 각자 고유한 **짐(상태)** 과 **행동** 을 가짐
- 다른 것들과 **정보를 주고받거나**, 특수한 방식으로 동작함
- **컴퓨터 프로그램 속 객체로 참여** 가능

예시:
- 테트리스 게임의 블록들
- 한글 프로그램의 메뉴나 버튼
- "좌회전" 신호 기능 등

---

## 캡슐화 (Encapsulation)

- 외부에서 내부 구조를 **직접 볼 수 없도록 보호**
- 내부 상태를 외부에서 **직접 변경할 수 없음**
- **자바에서 캡슐화**는 `private`, `getter/setter`로 구현

> 클래스(Class): 상태와 행동을 선언하고 내부적으로 감추는 구조  
> > 인스턴스는 클래스 기반으로 생성됨  
> > 예:  
> > - 클래스: 자동차 설계도  
> > - 인스턴스: 출고된 소나타 100대  

---

## 상속 (Inheritance)

- **상위 클래스의 속성과 기능**을 **하위 클래스가 물려받음**
- 하위 클래스는 **자신만의 추가 속성도 가질 수 있음**

예시:
- `나무`는 `식물`의 특성과 `서명`의 특성을 모두 가짐  
- `사람`은 `군인`의 속성을 가질 수 있으나 `식물`의 속성은 없음

> **상위 클래스 (Super Class)**: 일반적/공통적 속성  
> **하위 클래스 (Sub Class)**: 상속받아 구체화

---

## 다형성 (Polymorphism)

- 같은 이름의 메서드가 **상황에 따라 다르게 동작**
- **오버로딩/오버라이딩**을 통해 구현됨

예시:
- 서로 다른 클래스가 같은 `speak()` 메서드를 가지고 다르게 말함  
- 슈퍼 클래스가 정의한 메서드를 하위 클래스에서 다르게 구현

---

## 객체지향 프로그래밍의 목적

- 소프트웨어의 **생산성 향상**
- **재사용 가능**한 구성 요소를 빠르게 조립
- 현실 세계와 유사한 방식으로 **프로그래밍 구조화**

---

## 절차적 프로그래밍과 객체지향 프로그래밍

| 항목 | 절차적 프로그래밍 | 객체지향 프로그래밍 |
|------|--------------------|--------------------|
| 중심 | 함수 중심 | 객체 중심 |
| 유지보수 | 어려움 | 쉬움 |
| 재사용 | 제한적 | 높음 |
| 현실 세계 반영 | 약함 | 강함 |

---

## 핵심 개념 요약

- **클래스**: 상태(속성)과 행동(기능)을 설계한 설계도
- **객체**: 클래스를 기반으로 생성된 실체
- **캡슐화**: 내부 정보를 숨기고 외부에는 인터페이스만 제공
- **상속**: 기존 클래스를 바탕으로 확장
- **다형성**: 동일한 이름의 기능이 클래스에 따라 다르게 구현



## 4월 3일 (5주차)
scanner.nextint()로 정수 입력
InputMismatchException : scanner.nextint로 정수 이외의 것을 입력 받았을 때 예외처리.
Scanner.next() : 입력 스트림에 있는 정수 이외의 것을 버린다.


## 3월 27일 (4주차)
* 자바의 특징(3)
  1. 실시간 응용프로그램에 부적합

* 소스코드, 바이트 코드, 기계어의 차이점

* 식별자 : 클래스, 변수, 상수, 메소드 등에 붙이는 이름
* 식별자의 원칙
  1. @, #과 같은 특수문자 사용 X _, $는 사용 O
  2. 유니코드, 한글 사용 O
  3. 자바 키워드는 식별자로 사용 X
  4. 길이 제한 X

* JAVA 데이터 타입
  문자열 같은 경우 string 클래스로 표현
  리터럴 : 데이터 자체

* 참조 자료형
  JVM에서 포인터(주소) 안내를 해준다

* 참조 자료형 사용 이유
  1. 보안 강화(포인터를 사용하면 버퍼 오버플로우 같은 보안 취약점이 생기는데, java에서는 불가능함)
  2. 다중 플랫폼 지원
  3. 메모리 안정성
  4. 코드 단순화, 가속화 향상
  5. 다중 플랫폼 지원

* 메모리의 구조
  힙 (heap) : 프로그래머가 직접 공간을 할당, 해제하는 메모리
  스택 (stack) : 프로그램이 자동으로 사용하는 임시 메모리 
  각각 메모리가 침범하면 힙, 스택 오버플로우

* 변수 : 값을 임시로 저장하기 위한 메모리

* 비트 연산
  비트 논리 : AND, OR, XOR, NOT 연산
  시프트 : 비트를 오른쪽이나 왼쪽으로 이동시킴
  사용 이유 : 성능, 최적화가 중요한 경우 기본 연산자보다 비트 연산이 훨씬 빠르다
  

## 3월 20일 (3주차)
* 프로그래밍 언어의 진화 과정
  고급언어, 어셈블리어, 객체지향언어의 사용

* JVM : Java Varture Machine
  
* 사용자의 요구에 따라 java 9부터 모든 클래스를 모듈로 재구성했다.

* 자바 API
  자바 api를 사용하면서 자바 개발이 용이해졌다.

* 파스칼 케이스
  파일 이름을 생성할 때 첫 글자와 중간 글자를 대문자로 표기한다.

* 자바의 응용
  초기에는 거의 다 자바로 안드로이드 앱을 만들었다.

* 자바의 특징(1)
  1. 플랫폼 독립성
  2. 객체지향
  3. 클래스로 캡슐화
  4. 소스(.java)와 클래스(.class) 파일

* 자바의 특징(2)
  1. 다수 클래스 파일의 경우 jar 압축 파일로 실행 코드 배포
  2. 클래스를 패키지로 관리
  3. 자체 멀티스레드 지원
